#!/usr/bin/env python3
"""
Automated experiment runner for fall detection CCD experiments.

Reads the CCD experiment design from ccd_experiments.json (generated by
generate_ccd.py), then for every combination of:
    model  ×  experiment  ×  video
runs fall_detection_system.py in CLI + headless mode, captures the
total_falls count, and computes TP / FP / TN / FN statistics.

Output:  experiment_results.csv   — one row per (model, experiment, video)
         experiment_summary.csv   — aggregated TP/FP/TN/FN per (model, experiment)
"""

import json
import os
import re
import subprocess
import sys
import csv
import time
from pathlib import Path
from datetime import datetime

# ============================================================
# Configuration
# ============================================================

SCRIPT_DIR   = Path(__file__).resolve().parent
CCD_JSON     = SCRIPT_DIR / "ccd_experiments.json"
EXAMPLES_DIR = SCRIPT_DIR / "examples"
SYSTEM_SCRIPT = SCRIPT_DIR / "fall_detection_system.py"

# Python executable — uses the same interpreter that is running this script
PYTHON = sys.executable

# Regex to capture the machine-readable result line printed by
# fall_detection_system.py when it finishes processing a video.
RESULT_RE = re.compile(r"===RESULT===\s*total_falls=(\d+)")


# ============================================================
# Helpers
# ============================================================

def get_ground_truth(video_filename: str) -> bool:
    """Return True if the video is labelled as containing a fall (positive).

    Naming convention:
        *_pos.mov  → fall present  (positive)
        *_neg.mov  → no fall       (negative)
    """
    stem = Path(video_filename).stem.lower()  # e.g. "1_pos"
    if stem.endswith("pos"):
        return True
    elif stem.endswith("neg"):
        return False
    else:
        print(f"  [WARNING] Cannot determine label for '{video_filename}', assuming negative.")
        return False


def run_single_experiment(model: str, cli_args: dict, video_path: str,
                          timeout: int = 300) -> int:
    """Run fall_detection_system.py once and return the total_falls count.

    Parameters
    ----------
    model      : YOLO model filename (e.g. 'yolov12n.pt')
    cli_args   : dict mapping CLI flag to value, e.g. {'--conf': 0.5, ...}
    video_path : path to the input video file
    timeout    : max seconds to wait for the subprocess

    Returns
    -------
    int : total number of falls detected (0 means no fall detected)
          Returns -1 on error.
    """
    cmd = [
        PYTHON, str(SYSTEM_SCRIPT),
        "--mode", "cli",
        "--model", model,
        "--source", str(video_path),
        "--no-display",
    ]

    # Append experiment-specific parameters
    for flag, value in cli_args.items():
        cmd.extend([str(flag), str(value)])

    try:
        result = subprocess.run(
            cmd,
            cwd=str(SCRIPT_DIR),
            capture_output=True,
            text=True,
            timeout=timeout,
        )

        # Search for the result line in stdout
        output = result.stdout + result.stderr  # check both streams
        match = RESULT_RE.search(output)
        if match:
            return int(match.group(1))
        else:
            # Fallback: see if we can find it anywhere in output
            print(f"  [WARNING] Could not parse result line. Return code={result.returncode}")
            if result.stdout:
                # print last 5 lines for debugging
                lines = result.stdout.strip().split("\n")
                for line in lines[-5:]:
                    print(f"    stdout> {line}")
            if result.stderr:
                lines = result.stderr.strip().split("\n")
                for line in lines[-5:]:
                    print(f"    stderr> {line}")
            return -1

    except subprocess.TimeoutExpired:
        print(f"  [ERROR] Timeout ({timeout}s) for model={model} video={video_path}")
        return -1
    except Exception as exc:
        print(f"  [ERROR] {exc}")
        return -1


# ============================================================
# Main
# ============================================================

def main():
    # ------ Load CCD design ------
    if not CCD_JSON.exists():
        print(f"ERROR: {CCD_JSON} not found. Run generate_ccd.py first.")
        sys.exit(1)

    with open(CCD_JSON) as f:
        ccd = json.load(f)

    design_info = ccd["design_info"]
    experiments = ccd["experiments"]  # dict: model -> list of experiment dicts
    models = design_info["models"]

    # ------ Discover example videos ------
    if not EXAMPLES_DIR.exists():
        print(f"ERROR: examples directory not found at {EXAMPLES_DIR}")
        sys.exit(1)

    video_files = sorted([
        f for f in os.listdir(EXAMPLES_DIR)
        if f.lower().endswith((".mov", ".mp4", ".avi", ".mkv"))
    ])

    if not video_files:
        print(f"ERROR: No video files found in {EXAMPLES_DIR}")
        sys.exit(1)

    print("=" * 70)
    print("  Fall Detection — Automated CCD Experiment Runner")
    print("=" * 70)
    print(f"  Models           : {len(models)}")
    print(f"  Experiments/model: {design_info['total_runs_per_model']}")
    print(f"  Videos           : {len(video_files)}")
    total_runs = len(models) * design_info["total_runs_per_model"] * len(video_files)
    print(f"  Total CLI runs   : {total_runs}")
    print("=" * 70)

    # ------ Prepare output files ------
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    detail_csv   = SCRIPT_DIR / f"experiment_results_{timestamp}.csv"
    summary_csv  = SCRIPT_DIR / f"experiment_summary_{timestamp}.csv"

    detail_fields = [
        "model", "experiment_id", "point_type",
        "conf", "fall_threshold", "angle_threshold",
        "video", "ground_truth", "predicted", "total_falls",
        "classification",
    ]
    summary_fields = [
        "model", "experiment_id", "point_type",
        "conf", "fall_threshold", "angle_threshold",
        "TP", "FP", "TN", "FN",
        "accuracy", "precision", "recall", "f1",
    ]

    detail_writer_file  = open(detail_csv, "w", newline="")
    detail_writer       = csv.DictWriter(detail_writer_file, fieldnames=detail_fields)
    detail_writer.writeheader()

    # Initialize summary CSV file with headers
    with open(summary_csv, "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=summary_fields)
        writer.writeheader()

    run_counter = 0
    start_time = time.time()

    for model in models:
        model_experiments = experiments[model]
        print(f"\n{'─' * 70}")
        print(f"  Model: {model}")
        print(f"{'─' * 70}")

        for exp in model_experiments:
            exp_id    = exp["experiment_id"]
            pt_type   = exp["point_type"]
            actuals   = exp["actual_levels"]
            cli_args  = exp["cli_args"]

            tp = fp = tn = fn = 0

            print(f"\n  Experiment {exp_id:>2d} ({pt_type:>9s})  "
                  f"conf={actuals['conf']:.4f}  "
                  f"fall_thr={actuals['fall_threshold']:.4f}  "
                  f"angle={actuals['angle_threshold']:.1f}")

            for video_file in video_files:
                video_path  = EXAMPLES_DIR / video_file
                ground_truth = get_ground_truth(video_file)  # True = fall exists

                run_counter += 1
                pct = run_counter / total_runs * 100
                print(f"    [{run_counter}/{total_runs} {pct:5.1f}%] {video_file:15s} "
                      f"(label={'POS' if ground_truth else 'NEG'}) … ", end="", flush=True)

                total_falls = run_single_experiment(model, cli_args, str(video_path))

                if total_falls < 0:
                    # Error — treat as no detection but flag it
                    predicted = False
                    classification = "ERROR"
                    print("ERROR")
                else:
                    predicted = total_falls > 0
                    if ground_truth and predicted:
                        classification = "TP"
                        tp += 1
                    elif not ground_truth and predicted:
                        classification = "FP"
                        fp += 1
                    elif not ground_truth and not predicted:
                        classification = "TN"
                        tn += 1
                    else:  # ground_truth and not predicted
                        classification = "FN"
                        fn += 1
                    print(f"falls={total_falls:>2d}  → {classification}")

                # Write detail row
                detail_writer.writerow({
                    "model": model,
                    "experiment_id": exp_id,
                    "point_type": pt_type,
                    "conf": actuals["conf"],
                    "fall_threshold": actuals["fall_threshold"],
                    "angle_threshold": actuals["angle_threshold"],
                    "video": video_file,
                    "ground_truth": "POS" if ground_truth else "NEG",
                    "predicted": "POS" if predicted else "NEG",
                    "total_falls": total_falls,
                    "classification": classification,
                })
                detail_writer_file.flush()

            # Compute metrics for this experiment
            total_samples = tp + fp + tn + fn
            accuracy  = (tp + tn) / total_samples if total_samples else 0
            precision = tp / (tp + fp) if (tp + fp) else 0
            recall    = tp / (tp + fn) if (tp + fn) else 0
            f1        = (2 * precision * recall / (precision + recall)
                         if (precision + recall) else 0)

            summary_row = {
                "model": model,
                "experiment_id": exp_id,
                "point_type": pt_type,
                "conf": actuals["conf"],
                "fall_threshold": actuals["fall_threshold"],
                "angle_threshold": actuals["angle_threshold"],
                "TP": tp, "FP": fp, "TN": tn, "FN": fn,
                "accuracy": round(accuracy, 4),
                "precision": round(precision, 4),
                "recall": round(recall, 4),
                "f1": round(f1, 4),
            }

            # Append to summary CSV file immediately
            with open(summary_csv, "a", newline="") as f:
                writer = csv.DictWriter(f, fieldnames=summary_fields)
                writer.writerow(summary_row)

            print(f"    ── TP={tp}  FP={fp}  TN={tn}  FN={fn}  "
                  f"Acc={accuracy:.2%}  Prec={precision:.2%}  "
                  f"Rec={recall:.2%}  F1={f1:.2%}")

    # Close detail CSV
    detail_writer_file.close()

    elapsed = time.time() - start_time
    print(f"\n{'=' * 70}")
    print(f"  DONE — {run_counter} runs in {elapsed:.1f}s ({elapsed/60:.1f} min)")
    print(f"  Detail  results : {detail_csv}")
    print(f"  Summary results : {summary_csv}")
    print(f"{'=' * 70}")


if __name__ == "__main__":
    main()
